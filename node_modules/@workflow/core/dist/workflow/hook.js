import { EventConsumerResult } from '../events-consumer.js';
import { WorkflowSuspension } from '../global.js';
import { webhookLogger } from '../logger.js';
import { hydrateStepReturnValue } from '../serialization.js';
import { withResolvers } from '../util.js';
export function createCreateHook(ctx) {
    return function createHookImpl(options = {}) {
        // Generate hook ID and token
        const correlationId = `hook_${ctx.generateUlid()}`;
        const token = options.token ?? ctx.generateNanoid();
        // Add hook creation to invocations queue
        ctx.invocationsQueue.push({
            type: 'hook',
            correlationId,
            token,
            metadata: options.metadata,
        });
        // Queue of hook events that have been received but not yet processed
        const payloadsQueue = [];
        // Queue of promises that resolve to the next hook payload
        const promises = [];
        let eventLogEmpty = false;
        webhookLogger.debug('Hook consumer setup', { correlationId, token });
        ctx.eventsConsumer.subscribe((event) => {
            // If there are no events and there are promises waiting,
            // it means the hook has been awaited, but an incoming payload has not yet been received.
            // In this case, the workflow should be suspended until the hook is resumed.
            if (!event) {
                eventLogEmpty = true;
                if (promises.length > 0) {
                    setTimeout(() => {
                        ctx.onWorkflowError(new WorkflowSuspension(ctx.invocationsQueue, ctx.globalThis));
                    }, 0);
                    return EventConsumerResult.Finished;
                }
            }
            // Check for hook_created event to remove this hook from the queue if it was already created
            if (event?.eventType === 'hook_created' &&
                event.correlationId === correlationId) {
                // Remove this hook from the invocations queue if it exists
                const index = ctx.invocationsQueue.findIndex((item) => item.type === 'hook' && item.correlationId === correlationId);
                if (index !== -1) {
                    ctx.invocationsQueue.splice(index, 1);
                }
                return EventConsumerResult.Consumed;
            }
            if (event?.eventType === 'hook_received' &&
                event.correlationId === correlationId) {
                if (promises.length > 0) {
                    const next = promises.shift();
                    if (next) {
                        // Reconstruct the payload from the event data
                        const payload = hydrateStepReturnValue(event.eventData.payload, ctx.globalThis);
                        next.resolve(payload);
                    }
                }
                else {
                    payloadsQueue.push(event);
                }
                return EventConsumerResult.Consumed;
            }
            return EventConsumerResult.NotConsumed;
        });
        // Helper function to create a new promise that waits for the next hook payload
        function createHookPromise() {
            const resolvers = withResolvers();
            if (payloadsQueue.length > 0) {
                const nextPayload = payloadsQueue.shift();
                if (nextPayload) {
                    const payload = hydrateStepReturnValue(nextPayload.eventData.payload, ctx.globalThis);
                    resolvers.resolve(payload);
                    return resolvers.promise;
                }
            }
            if (eventLogEmpty) {
                // If the event log is already empty then we know the hook will not be resolved.
                // Treat this case as a "step not run" scenario and suspend the workflow.
                setTimeout(() => {
                    ctx.onWorkflowError(new WorkflowSuspension(ctx.invocationsQueue, ctx.globalThis));
                }, 0);
            }
            promises.push(resolvers);
            return resolvers.promise;
        }
        const hook = {
            token,
            // biome-ignore lint/suspicious/noThenProperty: Intentionally thenable
            then(onfulfilled, onrejected) {
                return createHookPromise().then(onfulfilled, onrejected);
            },
            // Support `for await (const payload of hook) { â€¦ }` syntax
            async *[Symbol.asyncIterator]() {
                while (true) {
                    yield await this;
                }
            },
        };
        return hook;
    };
}
//# sourceMappingURL=hook.js.map