import ms from 'ms';
const BASE_URL = 'https://useworkflow.dev/err';
/**
 * @internal
 * Check if a value is an Error without relying on Node.js utilities.
 * This is needed for error classes that can be used in VM contexts where
 * Node.js imports are not available.
 */
function isError(value) {
    return (typeof value === 'object' &&
        value !== null &&
        'name' in value &&
        'message' in value);
}
/**
 * @internal
 * All the slugs of the errors used for documentation links.
 */
export const ERROR_SLUGS = {
    NODE_JS_MODULE_IN_WORKFLOW: 'node-js-module-in-workflow',
    START_INVALID_WORKFLOW_FUNCTION: 'start-invalid-workflow-function',
    SERIALIZATION_FAILED: 'serialization-failed',
    WEBHOOK_INVALID_RESPOND_WITH_VALUE: 'webhook-invalid-respond-with-value',
    WEBHOOK_RESPONSE_NOT_SENT: 'webhook-response-not-sent',
    FETCH_IN_WORKFLOW_FUNCTION: 'fetch-in-workflow',
};
/**
 * The base class for all Workflow-related errors.
 *
 * This error is thrown by the Workflow DevKit when internal operations fail.
 * You can use this class with `instanceof` to catch any Workflow DevKit error.
 *
 * @example
 * ```ts
 * try {
 *   await getRun(runId);
 * } catch (error) {
 *   if (error instanceof WorkflowError) {
 *     console.error('Workflow DevKit error:', error.message);
 *   }
 * }
 * ```
 */
export class WorkflowError extends Error {
    cause;
    constructor(message, options) {
        const msgDocs = options?.slug
            ? `${message}\n\nLearn more: ${BASE_URL}/${options.slug}`
            : message;
        super(msgDocs, { cause: options?.cause });
        this.cause = options?.cause;
        if (options?.cause instanceof Error) {
            this.stack = `${this.stack}\nCaused by: ${options.cause.stack}`;
        }
    }
    static is(value) {
        return isError(value) && value.name === 'WorkflowError';
    }
}
/**
 * Thrown when a Workflow API request fails.
 *
 * This error is thrown when HTTP requests to the Workflow backend fail,
 * typically due to network issues, invalid requests, or server errors.
 *
 * @example
 * ```ts
 * try {
 *   await startWorkflow('myWorkflow', input);
 * } catch (error) {
 *   if (error instanceof WorkflowAPIError) {
 *     console.error(`API error (${error.status}):`, error.message);
 *   }
 * }
 * ```
 */
export class WorkflowAPIError extends WorkflowError {
    status;
    code;
    url;
    constructor(message, options) {
        super(message, {
            cause: options?.cause,
        });
        this.name = 'WorkflowAPIError';
        this.status = options?.status;
        this.code = options?.code;
        this.url = options?.url;
    }
    static is(value) {
        return isError(value) && value.name === 'WorkflowAPIError';
    }
}
/**
 * Thrown when a workflow run fails during execution.
 *
 * This error indicates that the workflow encountered a fatal error
 * and cannot continue. The `error` property contains details about
 * what caused the failure.
 *
 * @example
 * ```
 * const run = await getRun(runId);
 * if (run.status === 'failed') {
 *   // WorkflowRunFailedError will be thrown
 * }
 * ```
 */
export class WorkflowRunFailedError extends WorkflowError {
    runId;
    error;
    constructor(runId, error) {
        super(`Workflow run "${runId}" failed: ${error}`, {});
        this.name = 'WorkflowRunFailedError';
        this.runId = runId;
        this.error = error;
    }
    static is(value) {
        return isError(value) && value.name === 'WorkflowRunFailedError';
    }
}
/**
 * Thrown when attempting to get results from an incomplete workflow run.
 *
 * This error occurs when you try to access the result of a workflow
 * that is still running or hasn't completed yet.
 */
export class WorkflowRunNotCompletedError extends WorkflowError {
    runId;
    status;
    constructor(runId, status) {
        super(`Workflow run "${runId}" has not completed`, {});
        this.name = 'WorkflowRunNotCompletedError';
        this.runId = runId;
        this.status = status;
    }
    static is(value) {
        return isError(value) && value.name === 'WorkflowRunNotCompletedError';
    }
}
/**
 * Thrown when the Workflow runtime encounters an internal error.
 *
 * This error indicates an issue with workflow execution, such as
 * serialization failures, starting an invalid workflow function, or
 * other runtime problems.
 */
export class WorkflowRuntimeError extends WorkflowError {
    constructor(message, options) {
        super(message, {
            ...options,
        });
        this.name = 'WorkflowRuntimeError';
    }
    static is(value) {
        return isError(value) && value.name === 'WorkflowRuntimeError';
    }
}
export class WorkflowRunNotFoundError extends WorkflowError {
    runId;
    constructor(runId) {
        super(`Workflow run "${runId}" not found`, {});
        this.name = 'WorkflowRunNotFoundError';
        this.runId = runId;
    }
    static is(value) {
        return isError(value) && value.name === 'WorkflowRunNotFoundError';
    }
}
export class WorkflowRunCancelledError extends WorkflowError {
    runId;
    constructor(runId) {
        super(`Workflow run "${runId}" cancelled`, {});
        this.name = 'WorkflowRunCancelledError';
        this.runId = runId;
    }
    static is(value) {
        return isError(value) && value.name === 'WorkflowRunCancelledError';
    }
}
/**
 * A fatal error is an error that cannot be retried.
 * It will cause the step to fail and the error will
 * be bubbled up to the workflow logic.
 */
export class FatalError extends Error {
    fatal = true;
    constructor(message) {
        super(message);
        this.name = 'FatalError';
    }
    static is(value) {
        return isError(value) && value.name === 'FatalError';
    }
}
/**
 * An error that can happen during a step execution, allowing
 * for configuration of the retry behavior.
 */
export class RetryableError extends Error {
    /**
     * The Date when the step should be retried.
     */
    retryAfter;
    constructor(message, options = {}) {
        super(message);
        this.name = 'RetryableError';
        let retryAfterSeconds;
        if (typeof options.retryAfter === 'string') {
            retryAfterSeconds = ms(options.retryAfter) / 1000;
        }
        else if (typeof options.retryAfter === 'number') {
            retryAfterSeconds = options.retryAfter;
        }
        else if (options.retryAfter instanceof Date) {
            retryAfterSeconds = (options.retryAfter.getTime() - Date.now()) / 1000;
        }
        else {
            retryAfterSeconds = 1;
        }
        this.retryAfter = new Date(Date.now() + retryAfterSeconds * 1000);
    }
    static is(value) {
        return isError(value) && value.name === 'RetryableError';
    }
}
//# sourceMappingURL=index.js.map