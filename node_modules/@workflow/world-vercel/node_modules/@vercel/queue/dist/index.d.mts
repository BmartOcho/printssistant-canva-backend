/**
 * Serializer/Deserializer interface for message payloads
 */
interface Transport<T = unknown> {
    /**
     * Serialize a value to a buffer or stream for transmission
     */
    serialize(value: T): Buffer | ReadableStream<Uint8Array>;
    /**
     * Deserialize a readable stream back to the original value
     */
    deserialize(stream: ReadableStream<Uint8Array>): Promise<T>;
    /**
     * Optional cleanup method for deserialized payloads that may contain resources
     * Should be called when the payload is no longer needed, especially in error cases
     * @param payload The deserialized payload to clean up
     */
    finalize?(payload: T): Promise<void>;
    /**
     * MIME type for this serialization format
     */
    contentType: string;
}
/**
 * Built-in JSON serializer/deserializer
 * This implementation reads the entire stream into memory for JSON parsing
 */
declare class JsonTransport<T = unknown> implements Transport<T> {
    readonly contentType = "application/json";
    readonly replacer?: Parameters<typeof JSON.parse>[1];
    readonly reviver?: Parameters<typeof JSON.parse>[1];
    constructor(options?: {
        replacer?: Parameters<typeof JSON.parse>[1];
        reviver?: Parameters<typeof JSON.parse>[1];
    });
    serialize(value: T): Buffer;
    deserialize(stream: ReadableStream<Uint8Array>): Promise<T>;
}
/**
 * Built-in Buffer serializer/deserializer (reads entire stream into a Buffer)
 */
declare class BufferTransport implements Transport<Buffer> {
    readonly contentType = "application/octet-stream";
    serialize(value: Buffer): Buffer;
    deserialize(stream: ReadableStream<Uint8Array>): Promise<Buffer>;
}
/**
 * Stream serializer/deserializer (pass-through for streaming binary data)
 * This is ideal for large payloads that don't need to be buffered in memory
 *
 * IMPORTANT: When using StreamTransport, you must call finalize(payload) when done
 * processing the message to prevent resource leaks, especially in error cases.
 * ConsumerGroup handles this automatically, but direct QueueClient usage requires manual cleanup.
 *
 * Example usage:
 * ```typescript
 * const transport = new StreamTransport();
 * try {
 *   for await (const message of client.receiveMessages(options, transport)) {
 *     // Process the stream...
 *     const reader = message.payload.getReader();
 *     // ... handle stream data
 *   }
 * } catch (error) {
 *   // Cleanup is handled automatically by ConsumerGroup
 *   // or manually: await transport.finalize(message.payload);
 * }
 */
declare class StreamTransport implements Transport<ReadableStream<Uint8Array>> {
    readonly contentType = "application/octet-stream";
    serialize(value: ReadableStream<Uint8Array>): ReadableStream<Uint8Array>;
    deserialize(stream: ReadableStream<Uint8Array>): Promise<ReadableStream<Uint8Array>>;
    finalize(payload: ReadableStream<Uint8Array>): Promise<void>;
}

/**
 * Vercel Queue Service client types
 */

/**
 * Shared options for publishing messages
 */
interface PublishOptions {
    /**
     * Unique key to prevent duplicate message submissions
     * @default random UUID
     */
    idempotencyKey?: string;
    /**
     * Message retention time in seconds
     * @default 86400 (24 hours)
     * @min 60
     * @max 86400
     */
    retentionSeconds?: number;
    /**
     * Explicit deployment identifier to include in the `Vqs-Deployment-Id` header
     * If provided, this takes precedence over any value from the environment
     */
    deploymentId?: string;
}
interface SendMessageOptions<T = unknown> extends PublishOptions {
    /**
     * The queue name to send the message to
     */
    queueName: string;
    /**
     * The message payload
     */
    payload: T;
}
interface SendMessageResponse {
    /**
     * The generated message ID
     */
    messageId: string;
}
interface Message<T = unknown> {
    /**
     * The message ID
     */
    messageId: string;
    /**
     * The deserialized message payload
     * Note: If using streaming transports, ensure proper cleanup by calling transport.finalize(payload)
     * when done processing, especially in error cases
     */
    payload: T;
    /**
     * Number of times this message has been delivered
     */
    deliveryCount: number;
    /**
     * When the message was created
     */
    createdAt: Date;
    /**
     * MIME type of the message content
     */
    contentType: string;
    /**
     * Unique ticket for this message delivery (required for delete/patch operations)
     */
    ticket: string;
}
/**
 * Result indicating the message should be timed out for retry later
 */
interface MessageTimeoutResult {
    /**
     * Time in seconds before the message becomes visible again
     */
    timeoutSeconds: number;
}
/**
 * Result returned by message handlers
 */
type MessageHandlerResult = void | MessageTimeoutResult;
/**
 * Message metadata provided to handlers
 */
interface MessageMetadata {
    messageId: string;
    deliveryCount: number;
    createdAt: Date;
    topicName: string;
    consumerGroup: string;
}
/**
 * Message handler function type
 */
type MessageHandler<T = unknown> = (message: T, metadata: MessageMetadata) => Promise<MessageHandlerResult> | MessageHandlerResult;
/**
 * Options for creating a ConsumerGroup instance
 */
interface ConsumerGroupOptions<T = unknown> {
    /**
     * Serializer/deserializer for the payload
     * @default JsonTransport instance
     */
    transport?: Transport<T>;
    /**
     * Time in seconds that messages will be invisible to other consumers
     * @default 30
     */
    visibilityTimeoutSeconds?: number;
    /**
     * How often to refresh the visibility timeout during processing (in seconds)
     * @default 10
     */
    refreshInterval?: number;
}
/**
 * Error thrown when a message is not found (404)
 */
declare class MessageNotFoundError extends Error {
    constructor(messageId: string);
}
/**
 * Error thrown when a message is not available for processing (409)
 * This can happen when the message is in the wrong state, already claimed, etc.
 */
declare class MessageNotAvailableError extends Error {
    constructor(messageId: string, reason?: string);
}
/**
 * Error thrown when message data is corrupted or can't be parsed
 */
declare class MessageCorruptedError extends Error {
    constructor(messageId: string, reason: string);
}
/**
 * Error thrown when there are no messages available in the queue (204)
 */
declare class QueueEmptyError extends Error {
    constructor(queueName: string, consumerGroup: string);
}
/**
 * Error thrown when a message is temporarily locked (423)
 */
declare class MessageLockedError extends Error {
    readonly retryAfter?: number;
    constructor(messageId: string, retryAfter?: number);
}
/**
 * Error thrown when authentication fails (401)
 */
declare class UnauthorizedError extends Error {
    constructor(message?: string);
}
/**
 * Error thrown when access is forbidden (403)
 */
declare class ForbiddenError extends Error {
    constructor(message?: string);
}
/**
 * Error thrown for bad requests (400)
 */
declare class BadRequestError extends Error {
    constructor(message: string);
}
/**
 * Error thrown for internal server errors (500)
 */
declare class InternalServerError extends Error {
    constructor(message?: string);
}
/**
 * Error thrown when batch limit parameter is invalid
 */
declare class InvalidLimitError extends Error {
    constructor(limit: number, min?: number, max?: number);
}

/**
 * Options for the consume method
 */
interface ConsumeOptions {
    /** The specific message ID to consume (if not provided, consumes next available message) */
    messageId?: string;
    /** Whether to skip downloading the payload (only allowed when messageId is provided) */
    skipPayload?: boolean;
}

/**
 * Options for the send function
 */
interface SendOptions<T = unknown> extends PublishOptions {
    /**
     * Serializer/deserializer for the payload
     * @default JsonTransport instance
     */
    transport?: Transport<T>;
}
/**
 * Send a message to a topic (shorthand for topic creation and publishing)
 * Uses the default QueueClient with automatic OIDC token detection
 * @param topicName Name of the topic to send to
 * @param payload The data to send
 * @param options Optional send options including transport and publish settings
 * @returns Promise with the message ID
 * @throws {BadRequestError} When request parameters are invalid
 * @throws {UnauthorizedError} When authentication fails
 * @throws {ForbiddenError} When access is denied (environment mismatch)
 * @throws {InternalServerError} When server encounters an error
 */
declare function send<T = unknown>(topicName: string, payload: T, options?: SendOptions<T>): Promise<{
    messageId: string;
}>;
/**
 * Options for the receive function
 */
interface ReceiveOptions<T = unknown> extends ConsumerGroupOptions<T>, ConsumeOptions {
}
/**
 * Receive a message from a topic (shorthand for topic and consumer group creation)
 * Uses the default QueueClient with automatic OIDC token detection
 * @param topicName Name of the topic to receive from
 * @param consumerGroup Name of the consumer group
 * @param handler Function to process the message
 * @returns Promise that resolves when the message is processed
 * @throws All the same errors as the underlying client methods
 */
declare function receive<T = unknown>(topicName: string, consumerGroup: string, handler: MessageHandler<T>, options?: ReceiveOptions<T>): Promise<void>;
/**
 * Receive a specific message by its ID with full payload
 * @param topicName Name of the topic to receive from
 * @param consumerGroup Name of the consumer group
 * @param handler Function to process the message
 * @param options Receive options with messageId specified
 * @returns Promise that resolves when the message is processed
 * @throws All the same errors as the underlying client methods
 */
declare function receive<T = unknown>(topicName: string, consumerGroup: string, handler: MessageHandler<T>, options: ReceiveOptions<T> & {
    messageId: string;
    skipPayload?: false | undefined;
}): Promise<void>;
/**
 * Receive a specific message by its ID without downloading the payload (metadata only)
 * @param topicName Name of the topic to receive from
 * @param consumerGroup Name of the consumer group
 * @param handler Function to process the message metadata (payload will be void)
 * @param options Receive options with messageId and skipPayload specified
 * @returns Promise that resolves when the message is processed
 * @throws All the same errors as the underlying client methods
 */
declare function receive<T = unknown>(topicName: string, consumerGroup: string, handler: MessageHandler<void>, options: ReceiveOptions<T> & {
    messageId: string;
    skipPayload: true;
}): Promise<void>;

/**
 * Configuration object with handlers for different topics and consumer groups
 */
type CallbackHandlers = {
    [topicName: string]: {
        [consumerGroup: string]: MessageHandler;
    };
};
/**
 * Parsed callback request information
 */
type ParsedCallbackRequest = {
    queueName: string;
    consumerGroup: string;
    messageId: string;
};
/**
 * Parse and validate callback request using CloudEvent specification
 *
 * Extracts queue information from CloudEvent format and validates
 * that all required fields are present.
 *
 * @param request The incoming webhook request
 * @returns Parsed queue information
 * @throws Error if required fields are missing
 *
 * @example
 * ```typescript
 * // In Next.js API route
 * export async function POST(request: Request) {
 *   try {
 *     const { queueName, consumerGroup, messageId } = parseCallback(request);
 *
 *     // Use the parsed information...
 *     await myWorkflow.handleWebhook(queueName, consumerGroup, messageId);
 *
 *     return Response.json({ status: "success" });
 *   } catch (error) {
 *     return Response.json({ error: error.message }, { status: 400 });
 *   }
 * }
 * ```
 */
declare function parseCallback(request: Request): Promise<ParsedCallbackRequest>;
/**
 * Simplified queue callback handler for Next.js route handlers
 *
 * Automatically extracts queue information from CloudEvent format
 * and routes to the appropriate handler based on topic and consumer group.
 *
 * @param handlers Object with topic-specific handlers organized by consumer groups
 * @returns A Next.js route handler function
 *
 * @example
 * ```typescript
 * // Single topic with multiple consumer groups
 * export const POST = handleCallback({
 *   "image-processing": {
 *     "compress": (message, metadata) => console.log("Compressing image", message),
 *     "resize": (message, metadata) => console.log("Resizing image", message),
 *   }
 * });
 *
 * // Multiple topics with consumer groups
 * export const POST = handleCallback({
 *   "user-events": {
 *     "welcome": (user, metadata) => console.log("Welcoming user", user),
 *     "analytics": (user, metadata) => console.log("Tracking user", user),
 *   },
 *   "order-events": {
 *     "fulfillment": (order, metadata) => console.log("Fulfilling order", order),
 *     "notifications": (order, metadata) => console.log("Notifying order", order),
 *   }
 * });
 * ```
 */
declare function handleCallback(handlers: CallbackHandlers): (request: Request) => Promise<Response>;

export { BadRequestError, BufferTransport, ForbiddenError, InternalServerError, InvalidLimitError, JsonTransport, type Message, MessageCorruptedError, type MessageHandler, type MessageHandlerResult, MessageLockedError, type MessageMetadata, MessageNotAvailableError, MessageNotFoundError, type MessageTimeoutResult, type ParsedCallbackRequest, type PublishOptions, QueueEmptyError, type ReceiveOptions, type SendMessageOptions, type SendMessageResponse, type SendOptions, StreamTransport, type Transport, UnauthorizedError, handleCallback, parseCallback, receive, send };
